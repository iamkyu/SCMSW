# 스레드와 잠금장치

## 1일차: 상호배제와 메모리 모델

### 멀티스레드 코드가 잘못될 수 있는 경우

1. 경쟁조건<sup>race condition</sup>
2. 메모리 가시성<sup>memory visibility</sup>
3. 교착상태<sup>dead lock</sup>


### 위험 요소를 피하는데 도움이 되는 규칙들

- 공유되는 변수에 대한 접근을 반드시 동기화
- 쓰는 스레드와 읽는 스레드 모두 동기화
- 여러개 잠금장치를 미맂 어해진 공통의 순서에 따라 요청
- 잠금장치를 가진 상태에서 외부 메서드를 호출하지 않음
- 잠금장치는 최대한 짧게 보유

### 자율학습
1. 초기화 안정성과 관련해서 자바 메모리 모델이 보장하는 것은? 스레드 사이에서 객체를 안전하게 주고받기 위해서 잠금장치를 사용하는 것이 항상 필요한가?
2. 중복확인 잠금장치 안티패턴이란 무엇인가? 왜 안티패턴으로 불리는가?

### 참고자료

- [윌리엄푸의 자바 메모리 모델](http://www.cs.umd.edu/~pugh/java/memoryModel/index.html#reference)
- [JSR 133 (Java Memory Model) FAQ 번역](http://qwefgh90.github.io/java/JSR-133-(Java-Memory-Model)-FAQ(%EB%B2%88%EC%97%AD)/)
- [Memory Visibility(메모리 가시성) 와 Memory Barrier(메모리 장벽)](http://blog.naver.com/jjoommnn/130037479493)
- [디자인 패턴으로 알아본 Double Checked Lock(DCL)](http://www.hanbit.co.kr/media/channel/view.html?cms_code=CMS6818849791)


## 2일차: 내재된 잠금장치를 넘어서
자바5 이전의 내재된 잠금장치는 다음과 같은 제약이 있었음
- 내재된 잠금장치를 얻으려다 블로킹 상태에 빠진 스레드를 원상복귀시킬 방법이 없음
- 내재된 장금장치를 얻으려고 노력하는 시간을 강제로 중단시키는 타임아웃 기능이 없음

### 명시적인 락
자바5 부터 포함된 `java.util.concurrent.locks.ReentrantLock`은 명시적인 락으로써 가로채기가 가능한 잠금장치. 락을 확보하고 해제하는 모든 작업이 명시적.


```java
Lock lock = new ReentrantLock();
// ...
lock.lock();
try {
    // 예외가 발생한 경우, 적절하게 내부 값을 복원해야 할 수도 있음
} finally {
    lock.unlock(); // 락 블록이 끝나는 시점에 락을 명시적으로 해제해야 함
}
```

`ReentrantLock`은 암묵적인 락만으로 해결할 수 없는 복잡한 상황에서 사용하기 위한 고급 동기화 기능. 다음과 같은 경우에만 사용하는 것이 좋음.
- 락을 확보할 때 타임아웃을 지정해야 하는 경우
- 폴링의 형태로 락을 확보하고자 하는 경우
- 락을 확보하느라 대기 상태에 들어가 있을 때 인터럽트를 걸어야 하는 경우
- 대기 상태 큐 처리 방법을 공정하게 해야 하는 경우
- 코드가 단일 블록의 형태를 넘어서는 경우

### 원자변수
잠금장치 대신 `java.util.concurrent.atomic` 패키지 아래 원자 변수를 사용하면 몇 가지 장점이 있다.
- 필요한 경우 잠금장치를 획득해야 한다는 사실을 잊는 것을 방지할 수 있음
- 잠금장치가 하나도 개입되지 않기 때문에 원자 변수에 대한 동작이 데드락에 걸리는 일도 불가능
- 원자변수는 잠금장치나 블로킹에 기대지 않고 동기화를 구현하는 논블로킹, 락프리 알고리즘의 기초를 제공함

### 자율학습
1. `ReentrantLock`은 공정성을 위한 인수를 지원. 잠금장치가 공정하다는 것은 무엇을 의미하는가?
    - 불공정한 방법을 사용하는 경우 순서 뛰어넘기<sup>barging</sup>가 일어나기도 함. 락을 확보하려는 시점에 해제되어 있으면 큐 목록을 뛰어넘어 락을 확보한다. 항상 공정하게 처리하면 스레드를 반드시 멈추고 다시 실행하는 동안 성능에 큰 지장을 줄 수 있다. 대부분의 경우 공정하게 순서를 관리해서 얻는 장점보다 불공정하게 처리해서 얻는 성능상의 이점이 크다. `ReentrantLock`의 기본값은 불공정<sup>nonfair</sup>이다.
2. `ReentrantReadWriteLock`은 `ReentrantLock`과 어떻게 다른가? 언제 사용하면 좋은가?
    - `ReentrantLock`은 표준적인 상호배제 락을 구현하는데, 상호배제규칙은 일반적으로 데이터 완전성을 보장하는데 너무 엄격한 특징을 가지며 병렬 프로그램의 장점을 필요 이상으로 제한 함.  읽기-쓰기 락을 사용하면 읽기 작업만 처리하는 다수의 스레드는 동기화된 값을 얼마든지 동시에 읽어갈 수 있다. 읽기 작업이 대부분인 데이터 구조에 읽기-쓰기 락을 사용하면 확장성을 높일 수 있다.
3. 불필요한 기상<sup>spurious wakeup</sup>이란 무엇인가? 언제 일어나며 좋은 코드에서는 그런 일이 일어나지 않아야 하는 이유는 무엇인가?
4. `AtomicIntegerFieldUpdater`는 무엇인가? 그것은 `AtomicInteger`와 어떻게 다른가? 

### 참고자료
- [브라이언 게츠 외 1명, 자바 병렬 프로그래밍](http://book.naver.com/bookdb/book_detail.nhn?bid=4683550)

## 3일차: 거인의 어깨 위에서
스레드를 만드는 것은 값싼 동작이긴 하지만 공짜는 아니다. 요청 때 마다 스레드를 생성하다 요청 처리 속도보다 요청이 많아지면 시스템 붕괴를 야기할 수 있다.

### 스레드풀
스레드를 미리 생성 된 스레드풀에서 꺼내 사용하고 이보다 많은 수의 요청이 발생하면 빈 스레드가 날 때까지 큐에서 대기한다. 들어오는 요청을 모두 빠르게 처리하는게 아니라 적어도 요청의 일부는 계속 서비스를 제공받을 수 있다.

#### 스레드풀의 크기
하드웨어가 무엇인지, 동시에 어떤 작업이 수행되는지 등 여러 요소에 의해 결정 되지만 계산을 집중적으로 수행하는 경우는 코어의 수와 동일한 수의 스레드를 풀에 담는 것이 일반적, IO 중심의 경우에는 코어보다 많은 수를 사용하는 편이 낫다.
이 원리를 염두해 두고 부하 테스트와 측정을 수행하여 결정하는 것이 좋다.

### 생산자-소비자 패턴
두개의 스레드를 만들어서 하나는 생산자로 정하고 하나는 소비자로 정한다.
이 패턴은 생산과 소비를 병렬로 처리할 수 있는데 이 때 지나친 경합이 발생하면 오히려 속도가 더 느려질 수 있다.

### 자율학습
1. ForkJoinPool에 대한 문서, fork/join 풀은 일반적인 스레드 풀과 어떻게 다른가?
2. 작업 훔치기<sup>work stealing</sup>은 무엇인가 어떤 도움을 주는가?
3. CountDownLatch와 CyclicBarrier는 어떤 차이가 있는가?
4. 암달의법칙은 무엇인가? 
