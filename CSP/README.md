# 순차 프로세스 통신


## 1일 차: 채널과 고 블록

### 클로저의 `core.async` 라이브러리
- https://github.com/clojure/core.async
고<sup>GO</sup>언어가 구현항 동시성 모델을 클로저로 구현. 채널과 고 블록이라는 두 개의 주요 기능 제공.

### 채널
채널은 스레드 안전성을 제공하는 큐.

```clojure
channels.core=> (def c (chan))
channels.core=> (thread (println "Read: " (<!! c) "from c)) 
; 채널에 >!!를 이용해 무언가 써 넣을 때까지 블로킹 됨

channels.core=> (>!! c "Hello Thread")
```

채널은 기본적으로 동시적(무버퍼). 따라서 채널에 무언가를 써넣는 동작은 다른 무언가가 메시지를 읽을 때까지 블로킹 됨.
임의로 채널에 버퍼를 전달할 수도 있는데 두 가지 전략이 있음. 

- Dropping buffer: 버퍼가 꽉차면 이후 내용을 버림.
- Sliding Buffer: 버퍼가 꽉차면 이전 내용을 버림.

단, 버퍼 채널은 자동적으로 크기가 커지는 전략은 제공하지 않음.

> "끝이 없는" 것처럼 보이는 자원이 있다고 해도 조만간 그 자원은 모두 사용되고 말 것이다. 그렇게 되는 이유는 프로그램 자체가 훨씬 커다란 문제를 해결하기 위해서 사용되기 때문일 수도 있고, 버퍼에 저장되는 데이터를 소비해야 하는 코드에 버그가 있어서 버퍼에 데이터가 무한히 쌓이기 때문일 수도 있다.

### 고블록


